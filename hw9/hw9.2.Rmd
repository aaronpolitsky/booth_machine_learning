# Part 2


```{r, echo=F, message=F}
library(igraph)
```

Specify a stochastic block matrix:
```{r}
# block matrix -- assortative
# our graph will have three communities
eps <- .021 # epsilon
f.e <- .5 # fraud-accomplice
M = matrix(c( eps,  f.e,   eps,
              f.e, 2*eps,  1-f.e - 2*eps,
              eps, 1-f.e -2*eps, 1-(1-f.e - 2*eps)), 
           nrow = 3)

# sample a random graph
# 100 nodes grouped into 3 communities
num.fraudsters <- num.accomplices <- 5
num.honest <- 90
rg = 
  sample_sbm(num.fraudsters + num.accomplices + num.honest, # number of nodes in a random graph 
             pref.matrix = M,      # stochastic block matrix M that tells us probability of forming a link between nodes -- needs to be symmetric for undirected graphs
             block.sizes = c(num.fraudsters,
                             num.accomplices,
                             num.honest),  # how many nodes belong to each community 
             loops = F,            # no loops (vertex that connects to itself)
             directed = F          # we want an undirected graph 
  ) 

# membership vector used to color vertices 
membership_vector = c(rep(1, num.fraudsters), 
                      rep(2, num.accomplices), 
                      rep(3, num.honest))

plot_layout = layout.fruchterman.reingold(rg)
plot(rg, 
     vertex.color=membership_vector,
     layout = plot_layout)
```

```{r}
# given a graph, we would like to uncover parameters of the model 
# that is likely to have generated the random graph
# in this example, we know that the graph was generated according to the stochastic block model
# we can compare the estimated parameters to the true parameters
#
# however, in practice, we only see a graph (that is, its adjacency matrix) 
# to evaluate our model, we use domain knowledge. for example, whether community 
# memberships of nodes make sense 

## estimate parameters using the lda package
library(lda)

result =
  mmsb.collapsed.gibbs.sampler(get.adjacency(rg),  # first parameter is the adjacency matrix
                               K = 3,              # we are fitting the graph using a stochastic block model with three groups
                               num.iterations=10000,    # this and the following parameters specify parameters of the fitting procedure  -- don't worry about this
                               alpha = 0.1,
                               burnin = 500L,
                               beta.prior = list(1, 1))

# this matrix tells us for each vertex what is the probability that it belongs to 
# one of the K communities
memberships = with(result, t(document_sums) / colSums(document_sums))
head(memberships,20)
```
Many of these are clearly probably in one community versus the others. 

```{r}

# the estimate of the stochastic block matrix M 
ratio = with(result, blocks.pos / (blocks.pos + blocks.neg))
ratio

# actual M
M
```
The ratio doesn't seem to approximate M very well, though.  
